import cv2
import numpy as np
import matplotlib.pyplot as plt

# ====================================================================
# --- FUNCIONES AUXILIARES ---
# ====================================================================

def mostrar_imagenes(imagenes, titulos, filas=2, cols=3, figsize=(16, 10)):
    """Función auxiliar para mostrar múltiples imágenes"""
    total = len(imagenes)
    fig, axes = plt.subplots(filas, cols, figsize=figsize)
    axes = axes.ravel()
    
    for i in range(len(axes)):
        if i < total:
            img = imagenes[i]
            if len(img.shape) == 2:
                axes[i].imshow(img, cmap='gray')
            else:
                axes[i].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
            axes[i].set_title(titulos[i])
        axes[i].axis('off')
    
    plt.tight_layout()
    plt.show()

def obtener_kernel_impar(valor):
    """Asegura que el tamaño del kernel sea impar y entero"""
    k = int(valor)
    if k % 2 == 0:
        k += 1
    return max(3, k) 

# ====================================================================
# --- FUNCIÓN PRINCIPAL DE SEGMENTACIÓN ---
# ====================================================================

def segmentar_monedas_final_v8(ruta_imagen):
    print("="*60)
    print("PROCESAMIENTO V8: CANNY + RELLENO DE CONTORNO (Anti-Fusión)")
    print("="*60)
    
    # 1. CARGA
    img_original = cv2.imread(ruta_imagen)
    if img_original is None:
        print("Error: No se pudo cargar la imagen.")
        return

    h, w = img_original.shape[:2]
    dim_min = min(h, w)
    area_total = h * w

    # 2. PREPROCESAMIENTO (GRAY + CLAHE)
    img_gray = cv2.cvtColor(img_original, cv2.COLOR_BGR2GRAY)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    img_clahe = clahe.apply(img_gray)
    
    # Suavizado Gaussiano dinámico (Necesario antes de Canny)
    k_blur = obtener_kernel_impar(dim_min * 0.005) # 0.5%
    img_blur = cv2.GaussianBlur(img_clahe, (k_blur, k_blur), 0)

    # 3. DETECCIÓN DE BORDES CANNY
    v = np.median(img_blur)
    sigma = 0.33 
    lower_thresh = int(max(0, (1.0 - sigma) * v))
    upper_thresh = int(min(255, (1.0 + sigma) * v))
    
    img_canny = cv2.Canny(img_blur, lower_thresh, upper_thresh)
    
    # 4. PASO CRÍTICO: RECONSTRUCCIÓN POR RELLENO DE CONTORNO
    
    # A. Encontrar contornos en la imagen de Canny (Bordes)
    # Usamos cv2.RETR_EXTERNAL para encontrar los bordes exteriores de los objetos.
    canny_contours, _ = cv2.findContours(img_canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # B. Crear una máscara negra y dibujar los contornos rellenos
    img_mascara = np.zeros_like(img_gray)
    
    # Dibujamos todos los contornos encontrados por Canny, rellenándolos (-1)
    # Esto crea objetos sólidos sin necesidad de dilatación agresiva.
    cv2.drawContours(img_mascara, canny_contours, -1, 255, -1)
    
    # 5. MORFOLOGÍA FINAL (LIMPIEZA DE HUECOS INTERNOS Y RUIDO)
    # Aplicamos un cierre y apertura pequeños para limpiar los restos de textura interna 
    # (como los puntos de los dados) o ruido de Canny.
    
    # Cierre: Rellena pequeños huecos internos
    k_close = obtener_kernel_impar(dim_min * 0.005) 
    kernel_close = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (k_close, k_close))
    img_clean = cv2.morphologyEx(img_mascara, cv2.MORPH_CLOSE, kernel_close, iterations=2)
    
    # Apertura: Elimina ruido fino
    k_open = obtener_kernel_impar(dim_min * 0.002) 
    kernel_open = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (k_open, k_open))
    img_clean = cv2.morphologyEx(img_clean, cv2.MORPH_OPEN, kernel_open, iterations=1)

    # 6. DETECCIÓN Y FILTRADO FINAL
    # Ahora buscamos contornos en la imagen limpia y sólida.
    contours, _ = cv2.findContours(img_clean, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contornos_validos = []
    img_resultados = img_original.copy()
    
    # Filtro de Área
    min_area = area_total * 0.0005 # 0.05%
    max_area = area_total * 0.20
    
    print(f"Filtro de Área: {int(min_area)} - {int(max_area)} px")
    
    for cnt in contours:
        area = cv2.contourArea(cnt)
        
        if min_area < area < max_area:
            perimetro = cv2.arcLength(cnt, True)
            if perimetro == 0: continue
            
            circularidad = 4 * np.pi * (area / (perimetro * perimetro))
            
            if circularidad > 0.3:
                contornos_validos.append(cnt)
                
                # Visualización
                cv2.drawContours(img_resultados, [cnt], -1, (0, 255, 0), 3)
                x, y, w_box, h_box = cv2.boundingRect(cnt)
                cv2.putText(img_resultados, f"#{len(contornos_validos)}", (x, y-10), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

    print(f"\nRESULTADOS V8:")
    print(f"  - Total de objetos segmentados: {len(contornos_validos)}")
    
    # 7. VISUALIZACIÓN
    imagenes = [
        img_clahe, 
        img_canny, 
        img_mascara, 
        img_clean, 
        img_resultados
    ]
    titulos = [
        '1. CLAHE', 
        '2. Bordes Canny', 
        '3. Máscara Rellenada (NUEVO)', 
        '4. Limpieza Final', 
        f'5. Resultado ({len(contornos_validos)} objs)'
    ]
    
    # Adaptar filas y columnas para el número de imágenes (5)
    mostrar_imagenes(imagenes, titulos, filas=2, cols=3)

segmentar_monedas_final_v8('Monedas.jpg')